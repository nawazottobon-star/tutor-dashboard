const fs = require('fs');

const functions = [
    '/**',
    ' * Get learners not active in last N days',
    ' */',
    'export async function getInactiveLearners(params: {',
    '    courseId: string;',
    '    cohortId?: string;',
    '    days: number;',
    '}) {',
    '    const all = await rankLearnersInCohort({ courseId: params.courseId, cohortId: params.cohortId || "" });',
    '    const active = await getActiveLearners(params);',
    '    const activeEmails = new Set(active.map(a => a.email));',
    '    return all.filter(l => !activeEmails.has(l.email));',
    '}',
    '',
    '/**',
    ' * Get learners active in last N hours',
    ' */',
    'export async function getRecentlyActiveLearners(params: {',
    '    courseId: string;',
    '    hours: number;',
    '}) {',
    '    const cutoff = new Date();',
    '    cutoff.setHours(cutoff.getHours() - params.hours);',
    '',
    '    const activeUsers = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT DISTINCT ON (mp.user_id) u.full_name as "fullName", u.email, mp.updated_at as "updatedAt"',
    '        FROM module_progress mp',
    '        JOIN users u ON mp.user_id::uuid = u.user_id',
    '        WHERE mp.course_id::text = ${params.courseId}',
    '        AND mp.updated_at >= ${cutoff}',
    '    `);',
    '',
    '    return activeUsers.map(a => ({',
    '        name: a.fullName,',
    '        email: a.email,',
    '        lastActivity: a.updatedAt,',
    '    }));',
    '}',
    '',
    '/**',
    ' * Detailed activity history for a learner',
    ' */',
    'export async function getLearnerActivityHistory(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '    days: number;',
    '}) {',
    '    const user = await prisma.user.findUnique({',
    '        where: { email: params.learnerEmail.toLowerCase() },',
    '        select: { userId: true },',
    '    });',
    '    if (!user) return { error: true, message: "Learner not found" };',
    '',
    '    const cutoff = new Date();',
    '    cutoff.setDate(cutoff.getDate() - params.days);',
    '',
    '    return await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT module_no, quiz_passed, updated_at as "updatedAt"',
    '        FROM module_progress',
    '        WHERE user_id::text = ${user.userId}',
    '        AND course_id::text = ${params.courseId}',
    '        AND updated_at >= ${cutoff}',
    '        ORDER BY updated_at DESC',
    '    `);',
    '}',
    '',
    '/**',
    ' * Get most frequently active learners',
    ' */',
    'export async function getMostActiveLearners(params: {',
    '    courseId: string;',
    '    limit: number;',
    '}) {',
    '    const activityCounts = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT user_id, COUNT(*) as "count"',
    '        FROM module_progress',
    '        WHERE course_id::text = ${params.courseId}',
    '        GROUP BY user_id',
    '        ORDER BY "count" DESC',
    '        LIMIT ${params.limit}',
    '    `);',
    '',
    '    const userIds = activityCounts.map(a => a.user_id);',
    '    const users = await prisma.user.findMany({',
    '        where: { userId: { in: userIds } },',
    '        select: { userId: true, fullName: true, email: true },',
    '    });',
    '',
    '    return activityCounts.map(a => {',
    '        const user = users.find(u => u.userId === a.user_id);',
    '        return {',
    '            name: user?.fullName,',
    '            email: user?.email,',
    '            activityCount: Number(a.count),',
    '        };',
    '    });',
    '}',
    '',
    '/**',
    ' * Get least frequently active learners',
    ' */',
    'export async function getLeastActiveLearners(params: {',
    '    courseId: string;',
    '    limit: number;',
    '}) {',
    '    const activityCounts = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT user_id, COUNT(*) as "count"',
    '        FROM module_progress',
    '        WHERE course_id::text = ${params.courseId}',
    '        GROUP BY user_id',
    '        ORDER BY "count" ASC',
    '        LIMIT ${params.limit}',
    '    `);',
    '',
    '    const userIds = activityCounts.map(a => a.user_id);',
    '    const users = await prisma.user.findMany({',
    '        where: { userId: { in: userIds } },',
    '        select: { userId: true, fullName: true, email: true },',
    '    });',
    '',
    '    return activityCounts.map(a => {',
    '        const user = users.find(u => u.userId === a.user_id);',
    '        return {',
    '            name: user?.fullName,',
    '            email: user?.email,',
    '            activityCount: Number(a.count),',
    '        };',
    '    });',
    '}',
    '',
    '/**',
    ' * Get activity breakdown by hour of day',
    ' */',
    'export async function getActivityByTimeOfDay(params: { courseId: string }) {',
    '    const activity = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT updated_at as "updatedAt"',
    '        FROM module_progress',
    '        WHERE course_id::text = ${params.courseId}',
    '    `);',
    '',
    '    const hoursBreakdown: Record<number, number> = {};',
    '    for (let i = 0; i < 24; i++) hoursBreakdown[i] = 0;',
    '',
    '    activity.forEach(a => {',
    '        const hour = new Date(a.updatedAt).getHours();',
    '        hoursBreakdown[hour]++;',
    '    });',
    '',
    '    return hoursBreakdown;',
    '}',
    '',
    '/**',
    ' * Get activity breakdown by day of week',
    ' */',
    'export async function getActivityByDayOfWeek(params: { courseId: string }) {',
    '    const activity = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT updated_at as "updatedAt"',
    '        FROM module_progress',
    '        WHERE course_id::text = ${params.courseId}',
    '    `);',
    '',
    '    const daysBreakdown: Record<string, number> = {',
    '        "Sunday": 0, "Monday": 0, "Tuesday": 0, "Wednesday": 0,',
    '        "Thursday": 0, "Friday": 0, "Saturday": 0',
    '    };',
    '    const daysArr = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];',
    '',
    '    activity.forEach(a => {',
    '        const day = daysArr[new Date(a.updatedAt).getDay()];',
    '        daysBreakdown[day]++;',
    '    });',
    '',
    '    return daysBreakdown;',
    '}',
    '',
    '/**',
    ' * Identify learners at risk of dropping out',
    ' */',
    'export async function getDropoutRiskLearners(params: { courseId: string }) {',
    '    const atRisk = await getAtRiskLearners({ ...params, thresholdPercent: 20 });',
    '    const inactive = await getActiveLearners({ ...params, days: 7 });',
    '    const activeEmails = new Set(inactive.map(i => i.email));',
    '',
    '    return atRisk.filter(l => !activeEmails.has(l.email));',
    '}',
    '',
    '/**',
    ' * Learners with < 30% completion',
    ' */',
    'export async function getStrugglingLearners(params: {',
    '    courseId: string;',
    '    cohortId?: string;',
    '}) {',
    '    return await getAtRiskLearners({ ...params, thresholdPercent: 30 });',
    '}',
    '',
    '/**',
    ' * No progress recorded in last N days',
    ' */',
    'export async function getStagnantLearners(params: {',
    '    courseId: string;',
    '    days: number;',
    '}) {',
    '    return await getInactiveLearners(params);',
    '}',
    '',
    '/**',
    ' * Learners who failed quizzes 3+ times',
    ' */',
    'export async function getLearnersNeedingHelp(params: { courseId: string }) {',
    '    const attempts = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT user_id, module_no, COUNT(*) as count ',
    '        FROM module_progress ',
    '        WHERE course_id::text = ${params.courseId} AND quiz_passed = false ',
    '        GROUP BY user_id, module_no ',
    '        HAVING COUNT(*) >= 3',
    '    `);',
    '',
    '    const userIds = attempts.map(n => n.user_id);',
    '    const users = await prisma.user.findMany({',
    '        where: { userId: { in: userIds } },',
    '        select: { userId: true, fullName: true, email: true },',
    '    });',
    '',
    '    return attempts.map(n => {',
    '        const user = users.find(u => u.userId === n.user_id);',
    '        return {',
    '            name: user?.fullName,',
    '            email: user?.email,',
    '            moduleNo: n.module_no,',
    '            failedAttempts: Number(n.count),',
    '        };',
    '    });',
    '}',
    '',
    '/**',
    ' * Check if a learner is stuck',
    ' */',
    'export async function getStuckIndicators(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const progress = await getLearnerProgress(params);',
    '    if ("error" in progress) return progress;',
    '    ',
    '    // Logic: No activity in 3+ days AND completion < 100%',
    '    const lastActivity = new Date(progress.lastActivity);',
    '    const diff = (new Date().getTime() - lastActivity.getTime()) / (1000 * 3600 * 24);',
    '    ',
    '    if (diff > 3 && progress.percent < 100) {',
    '        return { stuck: true, lastActivity, reason: "Inactivity on current module" };',
    '    }',
    '    return { stuck: false };',
    '}',
    '',
    '/**',
    ' * Learners who appear stuck',
    ' */',
    'export async function getLearnersStuckOnModule(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    return await getLearnersFailedModule(params);',
    '}',
    '',
    '/**',
    ' * Detailed module aggregate stats',
    ' */',
    'export async function getModuleStatistics(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    const rate = await getModuleCompletionRate(params);',
    '    const res = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT COUNT(*) as count ',
    '        FROM module_progress ',
    '        WHERE course_id::text = ${params.courseId} AND module_no = ${params.moduleNo}',
    '    `);',
    '    return { ...rate, totalAttempts: Number(res[0].count) };',
    '}',
    '',
    '/**',
    ' * List all who finished a module',
    ' */',
    'export async function getLearnersCompletedModule(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    const completions = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT u.full_name as "fullName", u.email ',
    '        FROM module_progress mp ',
    '        JOIN users u ON mp.user_id::uuid = u.user_id ',
    '        WHERE mp.course_id::text = ${params.courseId} AND mp.module_no = ${params.moduleNo} AND mp.quiz_passed = true',
    '    `);',
    '    return completions.map(c => ({ name: c.fullName, email: c.email }));',
    '}',
    '',
    '/**',
    ' * List all who have failed a module so far',
    ' */',
    'export async function getLearnersFailedModule(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    const fails = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT u.full_name as "fullName", u.email ',
    '        FROM module_progress mp ',
    '        JOIN users u ON mp.user_id::uuid = u.user_id ',
    '        WHERE mp.course_id::text = ${params.courseId} AND mp.module_no = ${params.moduleNo} AND mp.quiz_passed = false',
    '    `);',
    '    return fails.map(f => ({ name: f.fullName, email: f.email }));',
    '}',
    '',
    '/**',
    ' * Avg attempts per module',
    ' */',
    'export async function getModuleAverageAttempts(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    const resCount = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT COUNT(*) as count ',
    '        FROM module_progress ',
    '        WHERE course_id::text = ${params.courseId} AND module_no = ${params.moduleNo}',
    '    `);',
    '    const totalAttempts = Number(resCount[0].count);',
    '',
    '    const resUsers = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT DISTINCT user_id ',
    '        FROM module_progress ',
    '        WHERE course_id::text = ${params.courseId} AND module_no = ${params.moduleNo}',
    '    `);',
    '    const uniqueUsersCount = resUsers.length;',
    '',
    '    const avg = uniqueUsersCount > 0 ? (totalAttempts / uniqueUsersCount).toFixed(2) : 0;',
    '    return { moduleNo: params.moduleNo, averageAttempts: avg };',
    '}',
    '',
    '/**',
    ' * Rank modules by failure/difficulty',
    ' */',
    'export async function getModuleDifficultyRanking(params: { courseId: string }) {',
    '    const modules = await getCourseModuleList(params);',
    '    const difficulties = await Promise.all(',
    '        modules.map(async m => {',
    '            const avg = await getModuleAverageAttempts({',
    '                courseId: params.courseId,',
    '                moduleNo: m.moduleNo,',
    '            });',
    '            return { moduleNo: m.moduleNo, title: m.moduleName, avgAttempts: avg.averageAttempts };',
    '        })',
    '    );',
    '    return difficulties.sort((a, b) => Number(b.avgAttempts) - Number(a.avgAttempts));',
    '}',
    '',
    '/**',
    ' * Progress growth over time',
    ' */',
    'export async function getProgressOverTime(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const history = await getLearnerActivityHistory({ ...params, days: 365 });',
    '    if ("error" in history) return history;',
    '',
    '    return (history as any[])',
    '        .filter((h: any) => h.quiz_passed)',
    '        .sort((a: any, b: any) => new Date(a.updatedAt).getTime() - new Date(b.updatedAt).getTime());',
    '}',
    '',
    '/**',
    ' * Cohort enrollment trend',
    ' */',
    'export async function getEnrollmentTrend(params: {',
    '    courseId: string;',
    '    months: number;',
    '}) {',
    '    const cutoff = new Date();',
    '    cutoff.setMonth(cutoff.getMonth() - params.months);',
    '',
    '    return await prisma.enrollment.findMany({',
    '        where: { courseId: params.courseId, enrolledAt: { gte: cutoff } },',
    '        select: { enrolledAt: true },',
    '        orderBy: { enrolledAt: "asc" },',
    '    });',
    '}',
    '',
    '/**',
    ' * "Why" diagnostic functions',
    ' */',
    '',
    'export async function getLearnerActivitySignals(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '    days: number;',
    '}) {',
    '    const history = await getLearnerActivityHistory(params) as any[];',
    '    if (history.length === 0) return ["long_inactivity"];',
    '    const signals = [];',
    '    if (history.length > 20) signals.push("high_engagement");',
    '    return signals;',
    '}',
    '',
    'export async function getModuleFailureReasons(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '    moduleNo: number;',
    '}) {',
    '    const attempts = await getModuleAttemptHistory(params) as any[];',
    '    return { attemptsCount: attempts.length, reason: "Multiple failed quiz attempts" };',
    '}',
    '',
    'export async function getDropoffPoints(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const progress = await getLearnerProgress(params);',
    '    if ("error" in progress) return progress;',
    '    return { lastModuleCompleted: progress.completedModules, dropoffModule: progress.completedModules + 1 };',
    '}',
    '',
    'export async function getCohortPerformanceFactors(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '}) {',
    '    const stats = await getCohortStats(params);',
    '    return {',
    '        factors: ["High engagement", "Regular activity"],',
    '        averageCompletion: (stats as any).averageCompletion',
    '    };',
    '}',
    '',
    'export async function getProgressBlockers(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    return await getStuckIndicators(params);',
    '}',
    '',
    '/**',
    ' * Get all learners in the course',
    ' */',
    'export async function getAllLearnersInCourse(params: { courseId: string }) {',
    '    const enrollments = await prisma.enrollment.findMany({',
    '        where: { courseId: params.courseId },',
    '        include: { user: { select: { fullName: true, email: true } } },',
    '    });',
    '    return enrollments.map(e => ({ name: e.user.fullName, email: e.user.email }));',
    '}',
    '',
    '/**',
    ' * Get all learners in a specific cohort',
    ' */',
    'export async function getAllLearnersInCohort(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '}) {',
    '    const members = await prisma.cohortMember.findMany({',
    '        where: { cohortId: params.cohortId, cohort: { courseId: params.courseId } },',
    '        include: { user: { select: { fullName: true, email: true } } },',
    '    });',
    '    return members.map(m => ({',
    '        name: m.user?.fullName || m.email.split("@")[0],',
    '        email: m.email,',
    '    }));',
    '}',
    '',
    '/**',
    ' * Get full learner details',
    ' */',
    'export async function getLearnerDetails(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    return await getLearnerProgress(params);',
    '}',
    '',
    '/**',
    ' * Get when a learner enrolled in the course',
    ' */',
    'export async function getLearnerEnrollmentDate(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const user = await prisma.user.findUnique({',
    '        where: { email: params.learnerEmail.toLowerCase() },',
    '        select: { userId: true },',
    '    });',
    '    if (!user) return { error: true, message: "Learner not found" };',
    '',
    '    const enrollment = await prisma.enrollment.findFirst({',
    '        where: { userId: user.userId, courseId: params.courseId },',
    '        select: { enrolledAt: true },',
    '    });',
    '    return enrollment ? { enrollmentDate: enrollment.enrolledAt } : { error: true, message: "Not enrolled" };',
    '}',
    '',
    '/**',
    ' * Get last activity time for a learner',
    ' */',
    'export async function getLearnerLastActivity(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const progress = await getLearnerProgress(params);',
    '    if ("error" in progress) return progress;',
    '    return { lastActivity: progress.lastActivity };',
    '}',
    '',
    '/**',
    ' * List all modules completed by a learner',
    ' */',
    'export async function getLearnerCompletedModules(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const progress = await getLearnerProgress(params);',
    '    if ("error" in progress) return progress;',
    '    return progress.moduleDetails.filter(m => m.completed);',
    '}',
    '',
    '/**',
    ' * List all modules not yet completed by a learner',
    ' */',
    'export async function getLearnerIncompleteModules(params: {',
    '    courseId: string;',
    '    learnerEmail: string;',
    '}) {',
    '    const progress = await getLearnerProgress(params);',
    '    if ("error" in progress) return progress;',
    '    return progress.moduleDetails.filter(m => !m.completed);',
    '}',
    '',
    '/**',
    ' * List all cohorts in the course',
    ' */',
    'export async function getAllCohortsInCourse(params: { courseId: string }) {',
    '    return await prisma.cohort.findMany({',
    '        where: { courseId: params.courseId },',
    '        select: { cohortId: true, name: true, isActive: true },',
    '    });',
    '}',
    '',
    '/**',
    ' * List only active cohorts',
    ' */',
    'export async function getActiveCohorts(params: { courseId: string }) {',
    '    return await prisma.cohort.findMany({',
    '        where: { courseId: params.courseId, isActive: true },',
    '        select: { cohortId: true, name: true },',
    '    });',
    '}',
    '',
    '/**',
    ' * Get number of members in a cohort',
    ' */',
    'export async function getCohortMemberCount(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '}) {',
    '    const count = await prisma.cohortMember.count({',
    '        where: { cohortId: params.cohortId, cohort: { courseId: params.courseId } },',
    '    });',
    '    return { count };',
    '}',
    '',
    '/**',
    ' * Get average completion percentage for a cohort',
    ' */',
    'export async function getCohortAverageCompletion(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '}) {',
    '    const stats = await getCohortStats(params);',
    '    if ("error" in stats) return stats;',
    '    return { averageCompletion: stats.averageCompletion };',
    '}',
    '',
    '/**',
    ' * Get top performers in a cohort',
    ' */',
    'export async function getCohortTopPerformers(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '    limit: number;',
    '}) {',
    '    return await getTopLearnersByCohort({ ...params, sortOrder: "desc" });',
    '}',
    '',
    '/**',
    ' * Get struggling performers in a cohort',
    ' */',
    'export async function getCohortBottomPerformers(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '    limit: number;',
    '}) {',
    '    return await getTopLearnersByCohort({ ...params, sortOrder: "asc" });',
    '}',
    '',
    '/**',
    ' * Get distribution of completion percentages in a cohort',
    ' */',
    'export async function getCohortCompletionDistribution(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '}) {',
    '    const learners = await getTopLearnersByCohort({',
    '        ...params,',
    '        limit: 1000,',
    '        sortOrder: "desc",',
    '    });',
    '',
    '    const ranges = {',
    '        "0-20%": 0,',
    '        "21-40%": 0,',
    '        "41-60%": 0,',
    '        "61-80%": 0,',
    '        "81-100%": 0,',
    '    };',
    '',
    '    learners.forEach(l => {',
    '        if (l.percent <= 20) ranges["0-20%"]++;',
    '        else if (l.percent <= 40) ranges["21-40%"]++;',
    '        else if (l.percent <= 60) ranges["41-60%"]++;',
    '        else if (l.percent <= 80) ranges["61-80%"]++;',
    '        else ranges["81-100%"]++;',
    '    });',
    '',
    '    return ranges;',
    '}',
    '',
    '/**',
    ' * Get percentage of learners active in last N days for a cohort',
    ' */',
    'export async function getCohortActivityRate(params: {',
    '    courseId: string;',
    '    cohortId: string;',
    '    days: number;',
    '}) {',
    '    const total = await getCohortMemberCount(params);',
    '    const active = await getActiveLearners(params);',
    '    const rate = total.count > 0 ? Math.floor((active.length / total.count) * 100) : 0;',
    '    return { activeCount: active.length, totalCount: total.count, activityRate: rate };',
    '}',
    '',
    '/**',
    ' * Get high-level overview of the course',
    ' */',
    'export async function getCourseOverview(params: { courseId: string }) {',
    '    const [totalEnrollments, averageCompletion, activeCohorts] = await Promise.all([',
    '        getTotalEnrollments(params),',
    '        getCourseAverageCompletion(params),',
    '        getActiveCohorts(params),',
    '    ]);',
    '',
    '    return {',
    '        totalEnrollments: totalEnrollments.count,',
    '        averageCompletion: averageCompletion.averageCompletion,',
    '        activeCohortsCount: activeCohorts.length,',
    '    };',
    '}',
    '',
    '/**',
    ' * Get total number of enrollments in the course',
    ' */',
    'export async function getTotalEnrollments(params: { courseId: string }) {',
    '    const count = await prisma.enrollment.count({ where: { courseId: params.courseId } });',
    '    return { count };',
    '}',
    '',
    '/**',
    ' * Get average completion percentage across all learners in the course',
    ' */',
    'export async function getCourseAverageCompletion(params: { courseId: string }) {',
    '    const learners = await getTopLearnersByCohort({',
    '        courseId: params.courseId,',
    '        limit: 10000,',
    '        sortOrder: "desc",',
    '    });',
    '',
    '    if (learners.length === 0) return { averageCompletion: 0 };',
    '',
    '    const sum = learners.reduce((acc, l) => acc + l.percent, 0);',
    '    return { averageCompletion: Math.floor(sum / learners.length) };',
    '}',
    '',
    '/**',
    ' * List all modules/topics in the course',
    ' */',
    'export async function getCourseModuleList(params: { courseId: string }) {',
    '    return await prisma.topic.findMany({',
    '        where: { courseId: params.courseId, moduleNo: { gt: 0 } },',
    '        select: { moduleNo: true, moduleName: true },',
    '        distinct: ["moduleNo"],',
    '        orderBy: { moduleNo: "asc" },',
    '    });',
    '}',
    '',
    '/**',
    ' * Get completion rate for a specific module across the course',
    ' */',
    'export async function getModuleCompletionRate(params: {',
    '    courseId: string;',
    '    moduleNo: number;',
    '}) {',
    '    const total = await getTotalEnrollments(params);',
    '    const completedCount = await prisma.$queryRaw<any[]>(Prisma.sql`',
    '        SELECT COUNT(*) as count ',
    '        FROM module_progress ',
    '        WHERE course_id::text = ${params.courseId} AND module_no = ${params.moduleNo} AND quiz_passed = true',
    '    `).then((res) => Number(res[0].count));',
    '',
    '    const rate = total.count > 0 ? Math.floor((completedCount / total.count) * 100) : 0;',
    '    return { moduleNo: params.moduleNo, completedCount, totalEnrollments: total.count, completionRate: rate };',
    '}',
];

fs.appendFileSync('src/services/tutorQueries.ts', functions.join('\n') + '\n');
console.log('Appended missing functions safely');
